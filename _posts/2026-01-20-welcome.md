---
layout: post
title: "Building a Mobile App to 'Shop Smart' "
date: 2026-01-20 10:00:00 +0530
---
If you are in Sri Lanka and enrolled your mobile number for various merchant loyalty schemes, you'll be likely to recieve many SMS texts with merchant offers, notifications that fills up your sms inbox. Consider that you shop at Keells, Cargils, Laughs & Glomark supermarkets and have 
two bank accounts and Sampath Bank and Commercial bank having two credit cards with them. Then your SMS inbox will look like below. <br> It is likely that you'd miss out an actually good offer notification. <br>

<img class="post-image" style="--post-image-width: 273px; --post-image-max: 320px;" src="{{ '/assets/images/inbox_nofilter.png' | relative_url }}" alt="SMS inbox example" width="90" height="260" />

What if there is a way to only see the active offers on a particular day, so that it saves time for you to read through the SMS , determine the merchant, offer active days, products applicable, offer details etc. <br>

<div class="post-image-row">
  <img class="post-image" style="--post-image-width: 273px; --post-image-max: 320px;" src="{{ '/assets/images/landing_page.jpeg' | relative_url }}" alt="Landing Page" width="90" height="260" />
  <img class="post-image" style="--post-image-width: 273px; --post-image-max: 320px;" src="{{ '/assets/images/merchant_summary.jpeg' | relative_url }}" alt="Glomark Offer Summary" width="90" height="260" />
</div>
So I vibe coded an Android app that does this. You can also code your own version. This is my way of learning the art of coding with AI by building something useful for me. This is infact the first time I built anything like this. So you can do better !<br>
I'll detail out how I did it. Along the way I had to learn new stuff and referenced somethings I've read. I'll try my best to give a full view without distracting you a lot. <br>

## Article outline
[Set Direction, Divide and Conquer](#divide-and-conquer-approach) <br>
[Assembling the tools](#assembleai) <br>
[Iterating for Modular design and Architecture](#architecture) <br>
[Imporant - How to give a spec to coding agents](#spec) <br>
[QA and error analysis](#erroranalysis)
[Setting up CICD for backend](#cicdbackend)

## Set Direction, Divide and Conquer {#divide-and-conquer-approach}

I follow [Simon Wilson](https://simonwillison.net/) 's writing. He posted about an [article by Mitchell Hashimoto](https://mitchellh.com/writing/building-large-technical-projects) ( Hashicorp founder ) that stuck with me. It was about how to structure large projects. <br>
I knew that my app would take some time. I knew I can't afford to put continuous hours. So whenever a progress is made, it should be easier for me to pick it up next and iterate. So holding everything in head isn't an option and I wanted an artefact trail. This aligns well with the article and that's why the article stuck with me I guess.

I knew that I wanted something material which would remind me ; to put effort , add more features and improve. <br> 
Luckily I had built one with ChatGPT help , which can dump selected SMS s to a .txt file. I used this .txt file sometime ago with Gemini to play around, to find out how easy / difficult it to pickup offer details from SMS text <br>

So I wanted to add more features to this app. This is how it looked<br>
<img class="post-image" style="--post-image-width: 273px; --post-image-max: 320px;" src="{{ '/assets/images/smsfilterapp.jpeg' | relative_url }}" alt="SMS Filter App" width="90" height="260" />

## Assembling the tools {#assembleai}

My only option is to build this with AI and I've been wanting to use AI coding agents. <br>
There are IDE based ones such as [Cursor](https://cursor.ai/), [VSCode with Amazon Q](https://marketplace.visualstudio.com/items?itemName=AmazonWebServices.amazon-q-vscode). Then there are CLI ones such as ; [Claude Code](https://claude.com/product/claude-code), [OpenAI Codex](https://openai.com/codex/), Gemini CLI. <br> I've been playing around with Cursor, VS Code with Q but decided to use CLI tool , so that I experience the nuances around it. <br>
To jump start, I took the [Claude Code short course by Anthropic](https://www.deeplearning.ai/short-courses/claude-code-a-highly-agentic-coding-assistant/) offered by [deeplearning.ai](https://www.deeplearning.ai/). I must say it is one of the best , well designed courses someone can take. Eventhough it is meant to be short course, if you follow through all the demos with your own Claude Code, it'll take 2-3 weeks to complete. It has such dense, high quality content. Highly recommend it. It would have cost me around USD 10 to trial the demos on Claude code with PAYG mode. But it was worth it. <br>
The course teach about general hints and development patterns to use CC such as using thinking modes, sub-agents, working on multiple features with git worktrees, using CC for Data Analysis, setting up MCP s and use for developing features. The course starts with building a chat app with RAG. Seeing the quality, I decided to take Anthropic's MCP short course on deeplearning.ai <br>

Also, I've seen some demos on [Google Stich](https://stitch.withgoogle.com/) ( for UX Design ), [Firebase Studio](https://studio.firebase.google.com/) & [Google AI Studio](https://aistudio.google.com/) ( for prototyping apps ) with promising vibe coding features. To stimulate the UI I tried all of them. The final UIs were designed by Stitch. <br>

<div class="post-image-row">
  <img class="post-image" style="--post-image-width: 273px; --post-image-max: 320px;" src="{{ '/assets/images/stichmainwindow.png' | relative_url }}" alt="stich landing page" width="100" height="75" />
  <img class="post-image" style="--post-image-width: 273px; --post-image-max: 320px;" src="{{ '/assets/images/stichcalander.png' | relative_url }}" alt="stich calander" width="100" height="75" />
</div>

When I instruct CC to adhere to the UI, I can extract the image or html of the UI and store it where CC can access. I gave the UI html to CC to build the mobile app front end.<br>

## Iterating for Modular design and Architecture {#architecture}

Initially I was deliberating between having a backend and decided do all processing on-device. Gemini LLM api is the only external system the app communicated with. <br>

So CC made the first working app. It did the following ;<br>
- filter SMS s based on sender
- call Gemini API to parse the offer messages and extract offer details, merchants, offer calander
- build on-device database ; raw offer text , parsed offer details,merchant master, offer master, user preferences ( including system prompt)
  
  The app could read SMS text , call Gemini API ( 2.5 flash - _coz it gave the best cost / token_) , determine if its valid offer or not, populate database.

  However, due to nature of offer messages, I realised that building merchant master will with prompting alone will be difficult. I tried few shot prompting etc, but the merchant database required some ground truth data ( _either internet lookup or merchant database_). Otherwise same merchant is identified by different names. Solving this means I need to incorporate more agentic / multi-step reasoning into parsing flow. Since LLM calls are orchestrated by device using java / kotlin , it was time consuming iteration. Further every iteration required the app to be built on Android Studio which took additional time. That was when I realised I need a backend service and decided to build one with [ Google's Antigravity ](https://antigravity.google/). Antigravity was super smooth and intelligent and I really like it <br>By this time I have migrated my Mobile Appdevelopment from Claude Code to Codex CLI ( _since I had ChatGPT Plus subscription it made sense to use codex. With GPT 5.1 it was as good as CC_)<br>
  I've used git worktrees to manage different app versions as it was easy to code, build and test them seperately.<br>
  
  With modularization, now I have a new challenge of synching requirements between two services. For backend developments, I went ahead with using actual SMS texts parsed as a JSON ( eumulating how the mobile app would call backend API ). With Antigravity, I built seperate scripts to emulate POST requests with JSON payloads, so I can test backend independently. Still my tests are running on local machine.<br>

To address the challenge of having ground truth merchant data, I decided to use [Google Places API](https://developers.google.com/maps/documentation/places/web-service/overview). Google places api has standardized places ( and merchants ). So whenever a merchant name is extracted from offer details, it was sent to Places API and retreived merchant's name as appear in Google. To further clean the name, I used another call to Gemini 2.5. All these finetuning is now easy as my backend is sperate.

## Imporant - How to specify requirement to coding agents {#spec}

It is always a good idea to write down your requirement first. This'll help in prompting as well as clear your thought process.<br>
In my codebase, I maintained a seperate 'requirements' folder. It contained my main requirement ; it outlined what happens when I click buttons, specified database table schemas and how database is updated. This is very much standard Business Analysis or FRS document. What I noted earlier is that both coding agent and owner ( me ) benefit immensly with such a document. This is a simple .md file. You can find the link here. <br>

If there is a change to the orignal spec, I've added the delta to the same spec with a seperate section highlighting only changes. Of course while writing this spec, you can brainstorm ideas with AI.<br>

When I decided to have a seperate service for backend, the backend project had a seperate spec. Specially specifying how it should interact with the Mobile app. In this spec I've included the details about JSON payloads it must process, how internal states should be maintained (_in first iteration it was file based. But I made provision to integrate to a document database_). By this time I've decided to host the backend in Azure (_for learning purposes of course_). I chose Azure Container Applications ( ACA) & Cosmos DB ( Document database) as my Azure Services. <br>
So when I create the backend with Antigravity I've passed these design instructions. Antigravity made necessary dockerfiles, requirement.txt, Cosmos DB connectors while managing enviornment variables in a seperate .env file. <br>

The repo can be found here; [repo]()

Amazon has [KIRO](https://kiro.dev/) which explictly says it is a spec driven AI coding tool. I've experienced that Amazon's Q getting more intelligent (  _powered by Claude 4 & above_). There is every reason to try KIRO out. <br>


## QA and error analysis {#erroranalysis}

[Andrew NG recently highlighted the importance of evals & error analysis as a differentiator](https://learn.deeplearning.ai/courses/agentic-ai/lesson/0kbds1/more-error-analysis-examples) and [something machine learning practioners can carry to Agentic AI development](https://www.linkedin.com/posts/andrewyng_deepseek-cuts-inference-costs-openai-tightens-activity-7384633283554447360-sVXe). This is remarkebly true !. <br>
I used jupyternotebooks to do data explorations and analysis to examine the mobile app database, offer parsing accuracy etc.<br>
However I find that the best experience comes with using AI in Colab & similar notebooks. When doing data anlysis on notebooks with Codex, CC, Antigravity the notebook gets re-created wiping out the results of cell exeuction. When you're woring on VSCode and have another agent like Q, you can generate code within the notebook which is much more helpful than using CLI too.

## Setting up CICD for backend {#cicdbackend)

Since my backend is supposed to run in ACA, I had to setup a CICD process.<br>
Since Azure didn't have any free tier for its container registry, I chose git container registry ( GCR ). With git worflows, new container is created when I push changes. <br>

In my Azure Container Apps ( ACA ), I configured GCR as a remote repository. <br>

All the Azure configurations were assisted by Antigravity. On my request it created a checklist and I've implemented each step. It was like following a lab tutorial. I was quite surprised the accuracy / upto date nature of the deployment guide that Antigravity produced.  <br>

<div class="post-image-row">
  <img class="post-image" style="--post-image-width: 273px; --post-image-max: 320px;" src="{{ '/assets/images/azuredeployguide.png' | relative_url }}" alt="Azure Deployment Guide" width="100" height="150" />
  <img class="post-image" style="--post-image-width: 273px; --post-image-max: 320px;" src="{{ '/assets/images/deploymenthelp.png' | relative_url }}" alt="Getting Deployment Help" width="100" height="150" />
</div>